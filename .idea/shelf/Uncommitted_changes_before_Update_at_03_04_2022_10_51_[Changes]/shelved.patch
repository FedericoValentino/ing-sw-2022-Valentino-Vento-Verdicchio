Index: src/main/java/model/CurrentGameState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\nimport model.boards.Cloud;\r\nimport model.boards.Islands;\r\nimport model.boards.Pouch;\r\nimport model.boards.token.MotherNature;\r\nimport model.boards.token.Student;\r\nimport model.cards.CharacterCard;\r\nimport model.cards.CharacterDeck;\r\n\r\nimport java.util.ArrayList;\r\n\r\n\r\npublic class CurrentGameState {\r\n    private CharacterDeck currentCharacterDeck;\r\n    private Pouch currentPouch;\r\n    private Islands currentIslands;\r\n    private ArrayList<Team> currentTeams;\r\n    private Cloud[] currentClouds;\r\n    private MotherNature currentMotherNature;\r\n    private CurrentTurnState currentTurnState;\r\n    private ArrayList<CharacterCard> currentActiveCharacterCard;\r\n    private ArrayList<Student> currentExtractedStudents;\r\n    private int bankBalance;\r\n    private boolean expertGame;\r\n\r\n    public CurrentGameState(int playerNum, boolean expertGame)\r\n    {\r\n       this.currentCharacterDeck = new CharacterDeck();\r\n       this.currentPouch = new Pouch();\r\n       this.currentIslands = new Islands();\r\n       this.currentTeams = new ArrayList<>();\r\n       //Aggiungere creazione team in base a num players\r\n       this.currentClouds = new Cloud[playerNum];\r\n       this.currentMotherNature = new MotherNature();\r\n       this.currentTurnState = new CurrentTurnState();\r\n       this.currentActiveCharacterCard = new ArrayList<>();\r\n       this.currentExtractedStudents = new ArrayList<>();\r\n       this.bankBalance = 20 - playerNum;\r\n       this.expertGame = expertGame;\r\n\r\n    }\r\n\r\n    public void insertExtractedStudent(Student s)\r\n    {\r\n        currentExtractedStudents.add(s);\r\n    }\r\n\r\n    public void checkWinner()\r\n    {\r\n        for(Team t: currentTeams)\r\n        {\r\n            for(Player p: t.getPlayers())\r\n            {\r\n                //da modificare perchè nella modalità a 4 giocatori 2 player non hanno torri\r\n                if(p.getPlayerSchool().getTowerCount() == 0)\r\n                {\r\n                    currentTurnState.updateWinner(t.getColor());\r\n                }\r\n                if(p.getAssistantDeck().checkEmpty())\r\n                {\r\n                    currentTurnState.lastTurn = true;\r\n                }\r\n            }\r\n        }\r\n        if(currentIslands.getTotalGroups() == 3)\r\n        {\r\n            currentTurnState.updateWinner(currentIslands.getMaxCol());\r\n        }\r\n        else if (currentPouch.checkEmpty())\r\n        {\r\n            currentTurnState.lastTurn = true;\r\n        }\r\n    }\r\n\r\n    public void updateBankBalance(Player p)\r\n    {\r\n        int coinsToLose = p.gainCoin();\r\n        if(coinsToLose <= bankBalance)\r\n        {\r\n            bankBalance -= coinsToLose;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    public int getBankBalance(){return bankBalance;}\r\n    public Islands getCurrentIslands(){return currentIslands;}\r\n    public CharacterDeck getCurrentCharacterDeck(){return currentCharacterDeck;}\r\n    public Pouch getCurrentPouch() {return currentPouch;}\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/model/CurrentGameState.java b/src/main/java/model/CurrentGameState.java
--- a/src/main/java/model/CurrentGameState.java	(revision 8cece4a4fb41f11dadffba745468843120e3a06a)
+++ b/src/main/java/model/CurrentGameState.java	(date 1648975864987)
@@ -15,7 +15,7 @@
     private CharacterDeck currentCharacterDeck;
     private Pouch currentPouch;
     private Islands currentIslands;
-    private ArrayList<Team> currentTeams;
+    private Team[] currentTeams;
     private Cloud[] currentClouds;
     private MotherNature currentMotherNature;
     private CurrentTurnState currentTurnState;
@@ -29,17 +29,23 @@
        this.currentCharacterDeck = new CharacterDeck();
        this.currentPouch = new Pouch();
        this.currentIslands = new Islands();
-       this.currentTeams = new ArrayList<>();
-       //Aggiungere creazione team in base a num players
+       if(playerNum == 2 || playerNum == 4)
+           this.currentTeams = new Team[2];
+       else if (playerNum == 3)
+           this.currentTeams = new Team[3];
        this.currentClouds = new Cloud[playerNum];
        this.currentMotherNature = new MotherNature();
        this.currentTurnState = new CurrentTurnState();
        this.currentActiveCharacterCard = new ArrayList<>();
        this.currentExtractedStudents = new ArrayList<>();
-       this.bankBalance = 20 - playerNum;
+       if(expertGame)
+           this.bankBalance = 20 - playerNum;
+       else
+           this.bankBalance = 0;
        this.expertGame = expertGame;
 
     }
+    //UpdateTurnState
 
     public void insertExtractedStudent(Student s)
     {
Index: src/main/java/model/boards/Island.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model.boards;\r\nimport model.Team;\r\nimport model.boards.token.Col;\r\nimport model.boards.token.ColTow;\r\nimport model.boards.token.Student;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Island\r\n{\r\n  public int islandId;\r\n  public boolean motherNature;\r\n  public boolean Group;\r\n  public ArrayList<Student> currentStudents;\r\n  private ColTow ownership;\r\n  public int towerNumber;\r\n  public int[] teamInfluence;\r\n  private boolean noEntry;\r\n\r\n  public Island(int islandId)\r\n  {\r\n    this.islandId = islandId;\r\n    this.currentStudents = new ArrayList<Student>();\r\n    this.motherNature = false;\r\n    this.Group = false;\r\n    this.towerNumber = 0;\r\n    this.ownership = null;\r\n    this.teamInfluence = new int[3];\r\n    this.noEntry = false;\r\n  }\r\n\r\n  public void calculateOwnership()\r\n  {\r\n    int max = 0;\r\n    if(motherNature)\r\n    {\r\n      for(int i: teamInfluence)\r\n      {\r\n        if(this.teamInfluence[i] > max)\r\n        {\r\n          max = this.teamInfluence[i];\r\n          switch(i)\r\n          {\r\n            case(0):\r\n              ownership = ColTow.BLACK;\r\n              break;\r\n            case(1):\r\n              ownership = ColTow.GREY;\r\n              break;\r\n            case(2):\r\n              ownership = ColTow.WHITE;\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public void updateTeamInfluence(Team[] team)\r\n  {\r\n    int numGREEN = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.GREEN).count();\r\n    int numYELLOW = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.YELLOW).count();\r\n    int numRED = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.RED).count();\r\n    int numPINK = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.PINK).count();\r\n    int numBLUE = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.BLUE).count();\r\n    int GREYinf = 0;\r\n    int BLACKinf = 0;\r\n    int WHITEinf = 0;\r\n    for(Team t: team)\r\n    {\r\n      switch(t.getColor()) {\r\n        case GREY:\r\n          if (t.getControlledProfessors().contains(Col.GREEN))\r\n            GREYinf += numGREEN;\r\n          if (t.getControlledProfessors().contains(Col.YELLOW))\r\n            GREYinf += numYELLOW;\r\n          if (t.getControlledProfessors().contains(Col.RED))\r\n            GREYinf += numRED;\r\n          if (t.getControlledProfessors().contains(Col.PINK))\r\n            GREYinf += numPINK;\r\n          if (t.getControlledProfessors().contains(Col.BLUE))\r\n            GREYinf += numBLUE;\r\n          break;\r\n\r\n        case BLACK:\r\n          if (t.getControlledProfessors().contains(Col.GREEN))\r\n            BLACKinf += numGREEN;\r\n          if (t.getControlledProfessors().contains(Col.YELLOW))\r\n            BLACKinf += numYELLOW;\r\n          if (t.getControlledProfessors().contains(Col.RED))\r\n            BLACKinf += numRED;\r\n          if (t.getControlledProfessors().contains(Col.PINK))\r\n            BLACKinf += numPINK;\r\n          if (t.getControlledProfessors().contains(Col.BLUE))\r\n            BLACKinf += numBLUE;\r\n          break;\r\n\r\n        case WHITE:\r\n          if (t.getControlledProfessors().contains(Col.GREEN))\r\n            WHITEinf += numGREEN;\r\n          if (t.getControlledProfessors().contains(Col.YELLOW))\r\n            WHITEinf += numYELLOW;\r\n          if (t.getControlledProfessors().contains(Col.RED))\r\n            WHITEinf += numRED;\r\n          if (t.getControlledProfessors().contains(Col.PINK))\r\n            WHITEinf += numPINK;\r\n          if (t.getControlledProfessors().contains(Col.BLUE))\r\n            WHITEinf += numBLUE;\r\n          break;\r\n      }\r\n    }\r\n    if(motherNature)\r\n    {\r\n      if(ownership == ColTow.WHITE)\r\n      {\r\n        WHITEinf++;\r\n      }\r\n      else if(ownership == ColTow.BLACK)\r\n      {\r\n        BLACKinf++;\r\n      }\r\n      else if(ownership == ColTow.GREY)\r\n      {\r\n        GREYinf++;\r\n      }\r\n    }\r\n    teamInfluence[0] = BLACKinf;\r\n    teamInfluence[1] = GREYinf;\r\n    teamInfluence[2] = WHITEinf;\r\n\r\n  }\r\n\r\n  public void addStudent(Student s)\r\n  {\r\n    currentStudents.add(s);\r\n  }\r\n\r\n  public ArrayList<Student> getCurrentStudents(){\r\n    return currentStudents;\r\n  }\r\n  public int getIslandId(){\r\n    return islandId;\r\n  }\r\n  public boolean getMotherNature(){\r\n    return motherNature;\r\n  }\r\n  public ColTow getOwnership(){return ownership;  }\r\n  public int[] getTeamInfluence() {return teamInfluence;  }\r\n  public boolean getNoEntry(){return noEntry;  }\r\n\r\n  public boolean isGroup() {\r\n    return Group;\r\n  }\r\n\r\n  public boolean isMotherNature() {\r\n    return motherNature;\r\n  }\r\n\r\n  public boolean isNoEntry() {\r\n    return noEntry;\r\n  }\r\n\r\n  public int getTowerNumber() {\r\n    return towerNumber;\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/model/boards/Island.java b/src/main/java/model/boards/Island.java
--- a/src/main/java/model/boards/Island.java	(revision 8cece4a4fb41f11dadffba745468843120e3a06a)
+++ b/src/main/java/model/boards/Island.java	(date 1648975864978)
@@ -20,7 +20,7 @@
   public Island(int islandId)
   {
     this.islandId = islandId;
-    this.currentStudents = new ArrayList<Student>();
+    this.currentStudents = new ArrayList<>();
     this.motherNature = false;
     this.Group = false;
     this.towerNumber = 0;
@@ -29,6 +29,7 @@
     this.noEntry = false;
   }
 
+
   public void calculateOwnership()
   {
     int max = 0;
@@ -39,18 +40,7 @@
         if(this.teamInfluence[i] > max)
         {
           max = this.teamInfluence[i];
-          switch(i)
-          {
-            case(0):
-              ownership = ColTow.BLACK;
-              break;
-            case(1):
-              ownership = ColTow.GREY;
-              break;
-            case(2):
-              ownership = ColTow.WHITE;
-              break;
-          }
+          this.ownership = ColTow.values()[i];
         }
       }
     }
@@ -58,76 +48,34 @@
 
   public void updateTeamInfluence(Team[] team)
   {
-    int numGREEN = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.GREEN).count();
-    int numYELLOW = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.YELLOW).count();
-    int numRED = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.RED).count();
-    int numPINK = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.PINK).count();
-    int numBLUE = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.BLUE).count();
-    int GREYinf = 0;
-    int BLACKinf = 0;
-    int WHITEinf = 0;
-    for(Team t: team)
-    {
-      switch(t.getColor()) {
-        case GREY:
-          if (t.getControlledProfessors().contains(Col.GREEN))
-            GREYinf += numGREEN;
-          if (t.getControlledProfessors().contains(Col.YELLOW))
-            GREYinf += numYELLOW;
-          if (t.getControlledProfessors().contains(Col.RED))
-            GREYinf += numRED;
-          if (t.getControlledProfessors().contains(Col.PINK))
-            GREYinf += numPINK;
-          if (t.getControlledProfessors().contains(Col.BLUE))
-            GREYinf += numBLUE;
-          break;
-
-        case BLACK:
-          if (t.getControlledProfessors().contains(Col.GREEN))
-            BLACKinf += numGREEN;
-          if (t.getControlledProfessors().contains(Col.YELLOW))
-            BLACKinf += numYELLOW;
-          if (t.getControlledProfessors().contains(Col.RED))
-            BLACKinf += numRED;
-          if (t.getControlledProfessors().contains(Col.PINK))
-            BLACKinf += numPINK;
-          if (t.getControlledProfessors().contains(Col.BLUE))
-            BLACKinf += numBLUE;
-          break;
-
-        case WHITE:
-          if (t.getControlledProfessors().contains(Col.GREEN))
-            WHITEinf += numGREEN;
-          if (t.getControlledProfessors().contains(Col.YELLOW))
-            WHITEinf += numYELLOW;
-          if (t.getControlledProfessors().contains(Col.RED))
-            WHITEinf += numRED;
-          if (t.getControlledProfessors().contains(Col.PINK))
-            WHITEinf += numPINK;
-          if (t.getControlledProfessors().contains(Col.BLUE))
-            WHITEinf += numBLUE;
-          break;
+    if(!noEntry)
+    {
+      int numGREEN = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.GREEN).count();
+      int numYELLOW = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.YELLOW).count();
+      int numRED = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.RED).count();
+      int numPINK = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.PINK).count();
+      int numBLUE = (int) currentStudents.stream().filter(Student -> Student.getColor() == Col.BLUE).count();
+      this.teamInfluence[0] = 0;
+      this.teamInfluence[1] = 0;
+      this.teamInfluence[2] = 0;
+      for(Team t: team)
+      {
+        if (t.getControlledProfessors().contains(Col.GREEN))
+          this.teamInfluence[t.getColor().ordinal()] += numGREEN;
+        if (t.getControlledProfessors().contains(Col.YELLOW))
+          this.teamInfluence[t.getColor().ordinal()]  += numYELLOW;
+        if (t.getControlledProfessors().contains(Col.RED))
+          this.teamInfluence[t.getColor().ordinal()] += numRED;
+        if (t.getControlledProfessors().contains(Col.PINK))
+          this.teamInfluence[t.getColor().ordinal()] += numPINK;
+        if (t.getControlledProfessors().contains(Col.BLUE))
+          this.teamInfluence[t.getColor().ordinal()] += numBLUE;
       }
-    }
-    if(motherNature)
-    {
-      if(ownership == ColTow.WHITE)
+      if(motherNature)
       {
-        WHITEinf++;
-      }
-      else if(ownership == ColTow.BLACK)
-      {
-        BLACKinf++;
+        this.teamInfluence[ownership.ordinal()]++;
       }
-      else if(ownership == ColTow.GREY)
-      {
-        GREYinf++;
-      }
     }
-    teamInfluence[0] = BLACKinf;
-    teamInfluence[1] = GREYinf;
-    teamInfluence[2] = WHITEinf;
-
   }
 
   public void addStudent(Student s)
Index: src/main/java/model/boards/Islands.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model.boards;\r\nimport model.boards.token.ColTow;\r\nimport model.boards.token.Student;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Islands extends Board {\r\n  private ArrayList<Island> islands;\r\n  private int totalGroups;\r\n\r\n  public Islands()\r\n  {\r\n    for(int i = 0; i < 12; i++)\r\n    {\r\n      islands.add(new Island(i));\r\n    }\r\n    totalGroups = 12;\r\n  }\r\n\r\n  public void idManagement()\r\n  {\r\n    Island currentIsland;\r\n    Island nextIsland;\r\n    Island previousIsland;\r\n    for(int i = 0; i < islands.size(); i++)\r\n    {\r\n      currentIsland = islands.get(i);\r\n      if(i == 0)\r\n      {\r\n        nextIsland = islands.get(i+1);\r\n        previousIsland = islands.get(islands.size()-1);\r\n      }\r\n      else if(i == islands.size()-1)\r\n      {\r\n        nextIsland = islands.get(0);\r\n        previousIsland = islands.get(i-1);\r\n      }\r\n      else\r\n      {\r\n        nextIsland = islands.get(i+1);\r\n        previousIsland = islands.get(i-1);\r\n      }\r\n      if(currentIsland.getOwnership() == nextIsland.getOwnership() && currentIsland.getOwnership() == previousIsland.getOwnership()) //Unione tripla\r\n      {\r\n        if(nextIsland.getMotherNature() || previousIsland.getMotherNature())\r\n        {\r\n          currentIsland.motherNature = true;\r\n        }\r\n        currentIsland.currentStudents.addAll(nextIsland.currentStudents);\r\n        currentIsland.currentStudents.addAll(previousIsland.currentStudents);\r\n        currentIsland.towerNumber += 2;\r\n        currentIsland.teamInfluence[0] += nextIsland.teamInfluence[0] + previousIsland.teamInfluence[0];\r\n        currentIsland.teamInfluence[1] += nextIsland.teamInfluence[1] + previousIsland.teamInfluence[1];\r\n        currentIsland.teamInfluence[2] += nextIsland.teamInfluence[2] + previousIsland.teamInfluence[2];\r\n        currentIsland.Group = true;\r\n        islands.set(i, currentIsland);\r\n        islands.remove(nextIsland);\r\n        islands.remove(previousIsland);\r\n      }\r\n      else if(currentIsland.isGroup())  //unione doppia(attuabile solo se currentIsland è di già un gruppo di isole\r\n      {\r\n        if(currentIsland.getOwnership() == nextIsland.getOwnership())\r\n        {\r\n          if(nextIsland.getMotherNature())\r\n          {\r\n            currentIsland.motherNature = true;\r\n          }\r\n          currentIsland.currentStudents.addAll(nextIsland.currentStudents);\r\n          currentIsland.towerNumber += 1;\r\n          currentIsland.teamInfluence[0] += nextIsland.teamInfluence[0];\r\n          currentIsland.teamInfluence[1] += nextIsland.teamInfluence[1];\r\n          currentIsland.teamInfluence[2] += nextIsland.teamInfluence[2];\r\n          islands.set(i, currentIsland);\r\n          islands.remove(nextIsland);\r\n        }\r\n        else if(currentIsland.getOwnership() == previousIsland.getOwnership())\r\n        {\r\n          if(previousIsland.getMotherNature())\r\n          {\r\n            currentIsland.motherNature = true;\r\n          }\r\n          currentIsland.currentStudents.addAll(previousIsland.currentStudents);\r\n          currentIsland.towerNumber += 1;\r\n          currentIsland.teamInfluence[0] += previousIsland.teamInfluence[0];\r\n          currentIsland.teamInfluence[1] += previousIsland.teamInfluence[1];\r\n          currentIsland.teamInfluence[2] += previousIsland.teamInfluence[2];\r\n          islands.set(i, currentIsland);\r\n          islands.remove(previousIsland);\r\n        }\r\n      }\r\n    }\r\n    for(int i = 0; i < islands.size(); i++)\r\n    {\r\n      Island I = islands.get(i);\r\n      I.islandId = i;\r\n      islands.set(i, I);\r\n    }\r\n\r\n  }\r\n\r\n  public void placeToken(Student s, int pos) {\r\n    Island I = islands.get(pos);\r\n    I.addStudent(s);\r\n    islands.set(pos, I);\r\n  }\r\n\r\n  public ColTow getMaxCol()\r\n  {\r\n    int[] Towers = new int[3];\r\n    int max = 0;\r\n    int Winner = 0;\r\n    for(Island I: islands)\r\n    {\r\n      if(I.getOwnership() == ColTow.BLACK)\r\n      {\r\n        Towers[0] += I.getTowerNumber();\r\n      }\r\n      if(I.getOwnership() == ColTow.GREY)\r\n      {\r\n        Towers[1] += I.getTowerNumber();\r\n      }\r\n      if(I.getOwnership() == ColTow.WHITE)\r\n      {\r\n        Towers[2] += I.getTowerNumber();\r\n      }\r\n    }\r\n    for(int i = 0; i < 2; i++)\r\n    {\r\n      if(Towers[i] > max)\r\n      {\r\n        max = Towers[i];\r\n        Winner = i;\r\n      }\r\n    }\r\n    switch(Winner)\r\n    {\r\n      case(0):\r\n        return ColTow.BLACK;\r\n      case(1):\r\n        return ColTow.GREY;\r\n      case(2):\r\n        return ColTow.WHITE;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public ArrayList<Island> getIslands() {\r\n    return islands;\r\n  }\r\n  public int getTotalGroups() {\r\n    return totalGroups;\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/model/boards/Islands.java b/src/main/java/model/boards/Islands.java
--- a/src/main/java/model/boards/Islands.java	(revision 8cece4a4fb41f11dadffba745468843120e3a06a)
+++ b/src/main/java/model/boards/Islands.java	(date 1648898413797)
@@ -113,15 +113,15 @@
     {
       if(I.getOwnership() == ColTow.BLACK)
       {
-        Towers[0] += I.getTowerNumber();
+        Towers[ColTow.BLACK.ordinal()] += I.getTowerNumber();
       }
       if(I.getOwnership() == ColTow.GREY)
       {
-        Towers[1] += I.getTowerNumber();
+        Towers[ColTow.GREY.ordinal()] += I.getTowerNumber();
       }
       if(I.getOwnership() == ColTow.WHITE)
       {
-        Towers[2] += I.getTowerNumber();
+        Towers[ColTow.WHITE.ordinal()] += I.getTowerNumber();
       }
     }
     for(int i = 0; i < 2; i++)
@@ -132,16 +132,7 @@
         Winner = i;
       }
     }
-    switch(Winner)
-    {
-      case(0):
-        return ColTow.BLACK;
-      case(1):
-        return ColTow.GREY;
-      case(2):
-        return ColTow.WHITE;
-    }
-    return null;
+    return ColTow.values()[Winner];
   }
 
   public ArrayList<Island> getIslands() {
